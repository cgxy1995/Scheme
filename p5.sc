(define (attacks? qi qj delta-rows)
 (or (= qi qj) (= (abs (- qi qj)) delta-rows)))
(define (nattacks? qi qj delta-rows)
 (not (or (= qi qj) (= (abs (- qi qj)) delta-rows))))
(define (list-of n f)
 (if (= n 0) '() (cons (f) (list-of (- n 1) f))))
(define (for-each p l)
 (unless (null? l)
  (p (first l))
  (for-each p (rest l))))
(define (for-each-indexed p l)
 (define (loop l i)
  (unless (null? l)
   (p (first l) i)
   (loop (rest l) (+ i 1))))
 (loop l 0))
(define (check-queens new-column old-columns)
 (for-each-indexed
  (lambda (old-column i)
   ;(place-queen i old-column)
   ;(write "place queen at")(write i)(write ",")(write old-column)(newline)
   (when (attacks? new-column old-column (+ i 1))
    (fail)))
  old-columns))
(define (n-queens n)
 (define (loop columns)
  (if (= (length columns) n)
      (draw-queens columns n)
      (let ((column (an-integer-between 0 (- n 1))))
       (draw-queens columns n)
       (check-queens column columns)
       (loop (cons column columns)))))
 (loop '()))
(define (place-n-queens-by-backtracking n)
 (n-queens n))
(define (draw-queens columns n)
 ;(write columns)(newline)
 (define (draw-queens-raw columns n)
  (unless (null? columns)
   ;(write "place queen at")(write (- n (length columns)))(write ",")(write (first columns))(newline)
   (place-queen (- n (length columns)) (first columns))
   (draw-queens-raw (rest columns) n)))
 (draw-queens-raw columns n))
(define (place-n-queens-by-constraints n)
 (let ((domain-variables (create-domain-variables n)))
  (for-each-indexed
   (lambda (domain-variable i)
    (attach-after-demon!
     (lambda ()
      (when (bound? domain-variable)
       (place-queen i (second (binding domain-variable)))))
     domain-variable))
   domain-variables)
  (for-each-indexed
   (lambda (domain-i i)
    (for-each-indexed
     (lambda (domain-j j)
      (when (not (= i j))
       (assert-constraint! not-attack (list domain-i domain-j))))
      domain-variables))
    domain-variables)
  (csp-solution domain-variables first)
  ))
(define (not-attack q1 q2)
 (not (or (= (second q1) (second q2))
	  (= (abs (- (second q1) (second q2)))
	     (abs (- (first q1) (first q2)))))))
(define (row-domain n r)
 (if (= n 0) '()
     (append (row-domain (- n 1) r)  (list (list r (- n 1))))))
(define (create-domain-variables n)
 (define (create-domain-variables-raw n i r)
  (if (= i 0) '()
      (append (list (create-domain-variable
		     (row-domain n r)))
	      (create-domain-variables-raw n (- i 1) (+ r 1)))))
 (create-domain-variables-raw n n 0))
;(define (assert-unary-constraint-gfc! constraint x)
; ())
(define (assert-unary-constraint-gfc! constraint x)
 (restrict-domain!
  x (remove-if (lambda (xelem) (not (constraint xelem)))
	       (domain-variable-domain x))))

(define (assert-binary-constraint-gfc! constraint x y)
 (attach-after-demon!
  (lambda ()
   (when (bound? x)
    (restrict-domain!
     y (remove-if (lambda (yelem) (not (constraint (binding x) yelem)))
		  (domain-variable-domain y)))))
  x)
 (attach-after-demon!
  (lambda ()
   (when (and (bound? y) (not (bound? x)))
    (restrict-domain!
     x (remove-if (lambda (xelem) (not (constraint xelem (binding y))))
		  (domain-variable-domain x)))))
  y))
(define (assert-unary-constraint-ac! constraint x)
 (restrict-domain!
  x (remove-if (lambda (xelem) (not (constraint xelem)))
	       (domain-variable-domain x))))
(define (assert-binary-constraint-ac! constraint x y)
 (attach-after-demon!
  (lambda ()
   (restrict-domain!
    y (remove-if (lambda (yelem)
		  (not (some (lambda (xelem) (constraint xelem yelem))
			     (domain-variable-domain x))))
		 (domain-variable-domain y))))
  x)
 (attach-after-demon!
  (lambda ()
   (restrict-domain!
    x (remove-if (lambda (xelem)
		  (not (some (lambda (yelem) (constraint xelem yelem))
			     (domain-variable-domain y))))
		 (domain-variable-domain x))))
  y))